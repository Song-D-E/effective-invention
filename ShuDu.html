<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ•°ç‹¬å°æ¸¸æˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#64748B',
                        success: '#10B981',
                        danger: '#EF4444',
                        warning: '#F59E0B',
                        info: '#06B6D4',
                        light: '#F8FAFC',
                        dark: '#1E293B',
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .sudoku-cell {
                @apply w-12 h-12 flex items-center justify-center text-xl font-medium transition-all duration-200 cursor-pointer border border-gray-200;
            }
            .sudoku-cell-selected {
                @apply bg-primary/20 border-primary;
            }
            .sudoku-cell-fixed {
                @apply bg-gray-100 text-dark font-bold;
            }
            .sudoku-cell-error {
                @apply bg-danger/20 text-danger;
            }
            .sudoku-cell-note {
                @apply text-xs font-normal grid grid-cols-3 grid-rows-3 gap-0.5 p-0.5;
            }
            .sudoku-cell-note-digit {
                @apply w-4 h-4 flex items-center justify-center opacity-50 hover:opacity-100;
            }
            .sudoku-grid-border {
                @apply border-2 border-gray-400;
            }
            .btn {
                @apply px-4 py-2 rounded-md font-medium transition-all duration-200 shadow-md hover:shadow-lg;
            }
            .btn-primary {
                @apply bg-primary text-white hover:bg-primary/90;
            }
            .btn-secondary {
                @apply bg-secondary text-white hover:bg-secondary/90;
            }
            .btn-danger {
                @apply bg-danger text-white hover:bg-danger/90;
            }
            .btn-success {
                @apply bg-success text-white hover:bg-success/90;
            }
            .number-pad {
                @apply grid grid-cols-3 gap-2 mx-auto;
            }
            .number-btn {
                @apply w-12 h-12 flex items-center justify-center text-xl font-bold rounded-md transition-all duration-200 shadow hover:shadow-md;
            }
            .game-header {
                @apply flex flex-col md:flex-row justify-between items-center gap-3 mb-4;
            }
            .stats-item {
                @apply flex items-center gap-2 bg-white p-2 rounded-lg shadow-sm;
            }
            .mobile-controls {
                @apply fixed bottom-0 left-0 right-0 bg-white p-4 shadow-lg z-10;
            }
            .game-container {
                @apply min-h-screen flex flex-col items-center justify-center p-4 bg-gradient-to-br from-blue-50 to-indigo-100;
            }
            .sudoku-container {
                @apply mx-auto overflow-hidden rounded-lg shadow-xl bg-white mb-4;
            }
        }
    </style>
</head>
<body class="font-sans antialiased">
    <div class="game-container">
        <div class="max-w-md w-full">
            <div class="game-header">
                <h1 class="text-[clamp(1.5rem,5vw,2.5rem)] font-bold text-dark">æ•°ç‹¬å°æ¸¸æˆ</h1>
                <div class="flex gap-2">
                    <div class="stats-item">
                        <i class="fa fa-clock-o text-primary"></i>
                        <span id="timer" class="text-dark">00:00</span>
                    </div>
                    <div class="stats-item">
                        <i class="fa fa-times text-danger"></i>
                        <span id="errors" class="text-dark">0</span>
                    </div>
                </div>
            </div>
            
            <div class="sudoku-container">
                <div id="sudoku-grid" class="grid grid-cols-9 grid-rows-9 sudoku-grid-border">
                    <!-- æ•°ç‹¬æ ¼å­å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            
            <div class="flex flex-col gap-3 mb-4">
                <div class="flex justify-between gap-2">
                    <button id="new-game" class="btn btn-primary w-full">
                        <i class="fa fa-refresh mr-1"></i> æ–°æ¸¸æˆ
                    </button>
                    <select id="difficulty" class="btn bg-gray-100 border border-gray-300 text-dark">
                        <option value="easy">ç®€å•</option>
                        <option value="medium" selected>ä¸­ç­‰</option>
                        <option value="hard">å›°éš¾</option>
                        <option value="expert">ä¸“å®¶</option>
                    </select>
                </div>
                
                <div class="flex justify-between gap-2">
                    <button id="toggle-notes" class="btn btn-secondary w-full">
                        <i class="fa fa-pencil mr-1"></i> ç¬”è®°æ¨¡å¼
                    </button>
                    <button id="check" class="btn btn-success w-full">
                        <i class="fa fa-check mr-1"></i> æ£€æŸ¥
                    </button>
                    <button id="hint" class="btn btn-warning w-full">
                        <i class="fa fa-lightbulb-o mr-1"></i> æç¤º
                    </button>
                </div>
            </div>
            
            <!-- ç§»åŠ¨ç«¯æ•°å­—é”®ç›˜ -->
            <div class="mobile-controls">
                <div class="number-pad">
                    <button class="number-btn bg-gray-100 hover:bg-gray-200" data-value="1">1</button>
                    <button class="number-btn bg-gray-100 hover:bg-gray-200" data-value="2">2</button>
                    <button class="number-btn bg-gray-100 hover:bg-gray-200" data-value="3">3</button>
                    <button class="number-btn bg-gray-100 hover:bg-gray-200" data-value="4">4</button>
                    <button class="number-btn bg-gray-100 hover:bg-gray-200" data-value="5">5</button>
                    <button class="number-btn bg-gray-100 hover:bg-gray-200" data-value="6">6</button>
                    <button class="number-btn bg-gray-100 hover:bg-gray-200" data-value="7">7</button>
                    <button class="number-btn bg-gray-100 hover:bg-gray-200" data-value="8">8</button>
                    <button class="number-btn bg-gray-100 hover:bg-gray-200" data-value="9">9</button>
                </div>
                <div class="flex justify-between mt-3">
                    <button id="delete" class="btn btn-danger w-1/2">
                        <i class="fa fa-trash mr-1"></i> åˆ é™¤
                    </button>
                    <button id="undo" class="btn btn-secondary w-1/2">
                        <i class="fa fa-undo mr-1"></i> æ’¤é”€
                    </button>
                </div>
            </div>
        </div>
        
        <!-- æ¸¸æˆå®Œæˆå¼¹çª— -->
        <div id="game-complete" class="fixed inset-0 flex items-center justify-center bg-black/50 z-50 hidden">
            <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-2xl transform transition-all">
                <div class="text-center">
                    <div class="text-5xl text-success mb-4">ğŸ‰</div>
                    <h2 class="text-2xl font-bold mb-2">æ­å–œå®Œæˆï¼</h2>
                    <p class="text-gray-600 mb-4">ä½ æˆåŠŸå®Œæˆäº†æ•°ç‹¬æ¸¸æˆ</p>
                    <div class="flex justify-center gap-4 mb-6">
                        <div class="stats-item">
                            <i class="fa fa-clock-o text-primary"></i>
                            <span id="final-time" class="text-dark">00:00</span>
                        </div>
                        <div class="stats-item">
                            <i class="fa fa-times text-danger"></i>
                            <span id="final-errors" class="text-dark">0</span>
                        </div>
                    </div>
                    <button id="play-again" class="btn btn-primary w-full">
                        <i class="fa fa-refresh mr-1"></i> å†ç©ä¸€æ¬¡
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // æ¸¸æˆçŠ¶æ€
            const gameState = {
                board: Array(9).fill().map(() => Array(9).fill(0)),
                solution: Array(9).fill().map(() => Array(9).fill(0)),
                notes: Array(9).fill().map(() => Array(9).fill().map(() => Array(9).fill(false))),
                selectedCell: null,
                isNoteMode: false,
                errors: 0,
                startTime: null,
                timerInterval: null,
                timeElapsed: 0,
                history: [],
            };

            // DOM å…ƒç´ 
            const sudokuGrid = document.getElementById('sudoku-grid');
            const numberButtons = document.querySelectorAll('.number-btn');
            const deleteButton = document.getElementById('delete');
            const undoButton = document.getElementById('undo');
            const toggleNotesButton = document.getElementById('toggle-notes');
            const checkButton = document.getElementById('check');
            const hintButton = document.getElementById('hint');
            const newGameButton = document.getElementById('new-game');
            const difficultySelect = document.getElementById('difficulty');
            const timerElement = document.getElementById('timer');
            const errorsElement = document.getElementById('errors');
            const gameCompleteModal = document.getElementById('game-complete');
            const finalTimeElement = document.getElementById('final-time');
            const finalErrorsElement = document.getElementById('final-errors');
            const playAgainButton = document.getElementById('play-again');

            // åˆå§‹åŒ–æ¸¸æˆ
            function initGame() {
                generateSudoku();
                renderBoard();
                startTimer();
                gameState.history = [];
            }

            // ç”Ÿæˆæ•°ç‹¬
            function generateSudoku() {
                // ç”Ÿæˆå®Œæ•´è§£
                solveSudoku(gameState.solution);
                
                // å¤åˆ¶å®Œæ•´è§£åˆ°æ¸¸æˆæ¿
                gameState.board = gameState.solution.map(row => [...row]);
                
                // æ ¹æ®éš¾åº¦ç§»é™¤æ•°å­—
                const difficulty = difficultySelect.value;
                let emptyCells;
                
                switch (difficulty) {
                    case 'easy':
                        emptyCells = 30;
                        break;
                    case 'medium':
                        emptyCells = 40;
                        break;
                    case 'hard':
                        emptyCells = 50;
                        break;
                    case 'expert':
                        emptyCells = 60;
                        break;
                    default:
                        emptyCells = 40;
                }
                
                // éšæœºç§»é™¤æ•°å­—
                let removed = 0;
                while (removed < emptyCells) {
                    const row = Math.floor(Math.random() * 9);
                    const col = Math.floor(Math.random() * 9);
                    
                    if (gameState.board[row][col] !== 0) {
                        gameState.board[row][col] = 0;
                        removed++;
                    }
                }
            }

            // è§£æ•°ç‹¬ï¼ˆå›æº¯ç®—æ³•ï¼‰
            function solveSudoku(board) {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (board[row][col] === 0) {
                            for (let num = 1; num <= 9; num++) {
                                if (isValidMove(board, row, col, num)) {
                                    board[row][col] = num;
                                    
                                    if (solveSudoku(board)) {
                                        return true;
                                    } else {
                                        board[row][col] = 0;
                                    }
                                }
                            }
                            
                            return false;
                        }
                    }
                }
                
                return true;
            }

            // æ£€æŸ¥ç§»åŠ¨æ˜¯å¦æœ‰æ•ˆ
            function isValidMove(board, row, col, num) {
                // æ£€æŸ¥è¡Œ
                for (let i = 0; i < 9; i++) {
                    if (board[row][i] === num) return false;
                }
                
                // æ£€æŸ¥åˆ—
                for (let i = 0; i < 9; i++) {
                    if (board[i][col] === num) return false;
                }
                
                // æ£€æŸ¥3x3æ–¹å—
                const startRow = Math.floor(row / 3) * 3;
                const startCol = Math.floor(col / 3) * 3;
                
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (board[startRow + i][startCol + j] === num) return false;
                    }
                }
                
                return true;
            }

            // æ¸²æŸ“æ•°ç‹¬æ¿
            function renderBoard() {
                sudokuGrid.innerHTML = '';
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.classList.add('sudoku-cell');
                        
                        // è®¡ç®—è¾¹æ¡†æ ·å¼ï¼Œå½¢æˆ3x3åŒºå—
                        if (row === 2 || row === 5) {
                            cell.classList.add('border-b-2', 'border-gray-400');
                        }
                        
                        if (col === 2 || col === 5) {
                            cell.classList.add('border-r-2', 'border-gray-400');
                        }
                        
                        // è®¾ç½®å•å…ƒæ ¼æ•°æ®å±æ€§
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // å›ºå®šå•å…ƒæ ¼ï¼ˆåˆå§‹æ•°å­—ï¼‰
                        if (gameState.board[row][col] !== 0 && gameState.solution[row][col] === gameState.board[row][col]) {
                            cell.classList.add('sudoku-cell-fixed');
                            cell.textContent = gameState.board[row][col];
                        } 
                        // ç©å®¶å¡«å…¥çš„æ•°å­—
                        else if (gameState.board[row][col] !== 0) {
                            cell.textContent = gameState.board[row][col];
                            
                            // æ£€æŸ¥æ˜¯å¦é”™è¯¯
                            if (gameState.board[row][col] !== gameState.solution[row][col]) {
                                cell.classList.add('sudoku-cell-error');
                            }
                        } 
                        // ç©ºç™½å•å…ƒæ ¼
                        else {
                            // æ¸²æŸ“ç¬”è®°
                            if (hasNotes(row, col)) {
                                renderNotes(cell, row, col);
                            }
                        }
                        
                        // æ·»åŠ é€‰ä¸­çŠ¶æ€
                        if (gameState.selectedCell && gameState.selectedCell.row === row && gameState.selectedCell.col === col) {
                            cell.classList.add('sudoku-cell-selected');
                        }
                        
                        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                        cell.addEventListener('click', () => selectCell(row, col));
                        
                        sudokuGrid.appendChild(cell);
                    }
                }
            }

            // æ£€æŸ¥å•å…ƒæ ¼æ˜¯å¦æœ‰ç¬”è®°
            function hasNotes(row, col) {
                return gameState.notes[row][col].some(note => note);
            }

            // æ¸²æŸ“ç¬”è®°
            function renderNotes(cell, row, col) {
                cell.classList.add('sudoku-cell-note');
                cell.innerHTML = '';
                
                for (let i = 0; i < 9; i++) {
                    const noteDigit = document.createElement('div');
                    noteDigit.classList.add('sudoku-cell-note-digit');
                    noteDigit.textContent = i + 1;
                    
                    if (gameState.notes[row][col][i]) {
                        noteDigit.classList.add('opacity-100', 'text-primary');
                    }
                    
                    cell.appendChild(noteDigit);
                }
            }

            // é€‰æ‹©å•å…ƒæ ¼
            function selectCell(row, col) {
                // ä¸èƒ½é€‰æ‹©å›ºå®šå•å…ƒæ ¼
                if (gameState.board[row][col] !== 0 && gameState.solution[row][col] === gameState.board[row][col]) {
                    return;
                }
                
                gameState.selectedCell = { row, col };
                renderBoard();
            }

            // è®¾ç½®å•å…ƒæ ¼å€¼
            function setCellValue(value) {
                if (!gameState.selectedCell) return;
                
                const { row, col } = gameState.selectedCell;
                
                // ä¿å­˜å†å²è®°å½•ç”¨äºæ’¤é”€
                saveHistory();
                
                if (gameState.isNoteMode) {
                    // ç¬”è®°æ¨¡å¼
                    toggleNote(value);
                } else {
                    // æ™®é€šæ¨¡å¼
                    gameState.board[row][col] = value;
                    
                    // æ¸…é™¤è¯¥å•å…ƒæ ¼çš„æ‰€æœ‰ç¬”è®°
                    gameState.notes[row][col] = Array(9).fill(false);
                    
                    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦å®Œæˆ
                    checkGameCompletion();
                }
                
                renderBoard();
            }

            // åˆ‡æ¢ç¬”è®°
            function toggleNote(value) {
                if (!gameState.selectedCell) return;
                
                const { row, col } = gameState.selectedCell;
                const noteIndex = value - 1;
                
                gameState.notes[row][col][noteIndex] = !gameState.notes[row][col][noteIndex];
            }

            // åˆ é™¤å•å…ƒæ ¼å†…å®¹
            function deleteCell() {
                if (!gameState.selectedCell) return;
                
                const { row, col } = gameState.selectedCell;
                
                // ä¸èƒ½åˆ é™¤å›ºå®šå•å…ƒæ ¼
                if (gameState.board[row][col] !== 0 && gameState.solution[row][col] === gameState.board[row][col]) {
                    return;
                }
                
                // ä¿å­˜å†å²è®°å½•ç”¨äºæ’¤é”€
                saveHistory();
                
                gameState.board[row][col] = 0;
                gameState.notes[row][col] = Array(9).fill(false);
                
                renderBoard();
            }

            // æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œ
            function undo() {
                if (gameState.history.length === 0) return;
                
                const previousState = gameState.history.pop();
                gameState.board = previousState.board.map(row => [...row]);
                gameState.notes = previousState.notes.map(row => row.map(note => [...note]));
                gameState.errors = previousState.errors;
                
                errorsElement.textContent = gameState.errors;
                renderBoard();
            }

            // ä¿å­˜å†å²è®°å½•
            function saveHistory() {
                gameState.history.push({
                    board: gameState.board.map(row => [...row]),
                    notes: gameState.notes.map(row => row.map(note => [...note])),
                    errors: gameState.errors
                });
                
                // é™åˆ¶å†å²è®°å½•é•¿åº¦
                if (gameState.history.length > 50) {
                    gameState.history.shift();
                }
            }

            // æ£€æŸ¥æ¸¸æˆå®Œæˆ
            function checkGameCompletion() {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        // å¦‚æœæœ‰å•å…ƒæ ¼ä¸ºç©ºæˆ–è€…å¡«é”™ï¼Œæ¸¸æˆæœªå®Œæˆ
                        if (gameState.board[row][col] === 0 || gameState.board[row][col] !== gameState.solution[row][col]) {
                            return false;
                        }
                    }
                }
                
                // æ¸¸æˆå®Œæˆ